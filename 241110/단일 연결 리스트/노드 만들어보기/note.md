# 단일 연결 리스트

## 노드의 정의

배열의 시간복잡도는 중간 삽입과 삭제의 시간복잡도가 O(N)이다.

O(1)과 O(N)의 효율은 매우 차이가 크기 때문에 삽입과 삭제가 빈번하게 일어나는 상황일면 배열은 비효율적이다. 

이런 문제를 해결하기 위해 등장한 자료구조가 연결리스트이다. 이 자료구조는 탐색은 느리지만 삽입과 삭제연산의 시간복잡도가 O(1)로 매우 빠르기 때문에 삽입과 삭제가 잦은 상황에서 자주 사용된다. 

연결리스트는 여러개의 노드가 모여서 형성되는 구조이다. 여기서 노드란 정보를 담는 하나의 창구이다. 일반적으로 노드는 데이터와 다른 노드로 이동하는 경로를 가진다. 

## 개념
단일 연결리스트는 연결방향이 단방향인 구조이다. 노드는 데이터와 다른 노드의 참조를 가지고 있다고 했는데 이때 노드가 가진 참조는 진행방향으로 이었을 때 바로 옆 노드를 의미한다. 

각 노드별로 data와 next 값을 가지고 있다고 가정하면, Data는 값을, Next는 그 다음 노드의 위치를 가리키는 역할을 한다. 

## 삽입/삭제/탐색
### 삽입
단일 연결리스트의 삽입은 추가될 새 노드를 가리킬 앞 노드의 next값을 변경함으로써 이루어진다. 

맨뒤쪽에 삽입하는 경우에는 맨 뒤 노드의 next값을 새 노드의 위치로 지정하면 연결 처리가 되고

중간에 삽입하는 경우, 앞 노드의 next값을 변경하고 새 노드의 next값을 기존에 이어져있던 뒤 노드의 위치로 지정하면 된다. 

### 삭제
삭제는 삽입과 유사하나, 삽입은 연결을 새로 정의하는 것과 반대로 연결을 제거해야 한다. 

예를 들어 중간에 있는 값이나 맨 뒤에 노드를 삭제하는 과정은 바로 앞 노드의 next값을 먼저 null로 바꾼 뒤 맨 뒤 값을 의미하는 tail을 그 전으로 옮겨주는 작업을 진행하면 된다. 

맨 앞에 있는 head는 head의 값을 head.next로 지정하면 끝난다. 

### 탐색
탐색의 경우 배열처럼 인덱스가 존재하지 않기 때문에 연결리스트를 순회하며 탐색해야 하므로 반드시 O(N)의 시간복잡도를 보인다. 

```
삽입과 삭제를 할 때 head와 tail을 같이 옮겨주는 이유는 탐색을 위한 것이다. 단일 연결리스트에서 시작부터 끝까지 이어주어야 head부터 출발하여 tail이 나오기 때문에 next를 따라가며 탐색을 진행할 수 있다. 
```



