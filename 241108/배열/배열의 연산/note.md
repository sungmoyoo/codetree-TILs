# 배열
배열을 사용할 때 배열에서 값을 담고, 값을 배열에서 삭제하고, 원하는 값을 배열에서 찾는데 이런 탐색, 삽입, 삭제 연산을 일반적으로 기본 연산이라고 한다. 

그렇다면 배열에서 탐색, 삽입, 삭제하는 경우 시간복잡도는 어떻게 될까?


## 삽입
실제로는 값을 어디에 삽입하냐에 따라 시간복잡도는 달라진다. 다만, 보통 시간복잡도는 최악의 상황에서의 시간복잡도에 관심이 있다. 

배열이 주어졌을 때 앞이나 가운데에 값을 넣는다고 가정하면, 새로운 값이 들어갈 자리를 확보하기 위해 다른 값들이 한칸씩 이동해야 한다. 

따라서 일반적으로 삽입의 시간복잡도는 O(N)이다. 
다만 항상 배열의 맨뒤에 새로운 값을 삽입하는 경우만 발생한다면 시간복잡도는 O(1)이다. 

## 삭제
삭제의 경우에도 맨뒤의 값만 제거하면 시간복잡도는 O(1)이다. 
최악의 경우, 맨 앞의 값을 삭제하게 된다면 나머지 N-1개의 값들이 모두 이동하므로 O(N)의 시간복잡도를 보인다.ㅌ

## 탐색
탐색의 가장 간단한 방법은 처음부터 모든 값을 탐색하는 것이다. 최악의 경우도 당연히 맨 끝에 값이 존재하는 경우이고 이 또한 시간복잡도가 O(N)이라고 볼 수 있다. 

```
*K번째 원소 값 구하기
배열이 주어졌을 때 k번째 원소는 index를 참조하면 바로 구할 수 있으므로 O(1)이다. 
```

# 문제
## 배열의 연산

배열은 우리가 흔히 사용하는, 데이터를 담는 자료구조입니다. 수업을 통해 그동안 크게 신경 쓰지 않고 사용했던 배열의 메서드들에 대한 시간복잡도를 배웠습니다.

다음 코드의 시간복잡도를 예측하여 봅시다.

(단 arr.find(x)는 x가 arr안에 있는지 확인하는 메소드이며, arr.remove(x)는 x번째 값을 삭제하라는 메소드이며, arr.add(x)는 arr의 맨 뒤에 x를 추가하라는 메소드입니다.)

```
function solution(arr)
  set result = []
  for i = 0 ... i < arr.size()
    if arr.find(i)
      result.add(1)
  
  result.remove(5)
  return result[5]
```
위 코드에서 최악의 경우는, i가 arr의 맨 끝에 존재하는 경우이다. 이 경우 for문을 0부터 arr.size()까지 돌면서 if 조건의 arr.find를 실행한다. arr.find(i)도 메소드 내부에서 arr의 모든 인덱스를 돈다.

따라서 위 코드의 시간복잡도는 O(N * N) = O(N^2)이다.